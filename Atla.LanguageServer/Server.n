using Atla.Lang.Parser;
using Atla.Lang.Parse;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Diagnostics;

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Atla.LanguageServer
{
    public class Server
    {
        mutable isInitialized: bool = false;
        public mutable isAvailablePublishDiagnostics: bool = false;
        public mutable tokenTypes: array[string] = array[];
        
        buffers: Hashtable[string, string] = Hashtable();
        
        public initialize(request: LSPRequestMessage): LSPResponseMessage {
            // check the client supoports publishDiagnostics.
            isAvailablePublishDiagnostics = try {
                request.content["params"]["capabilities"]["textDocument"]["publishDiagnostics"]["relatedInformation"].ToString().ToLower() == "true"
            } catch {
                | _ => false
            }
            def supportedTokenTypes = try {
                request.content["params"]["capabilities"]["textDocument"]["semanticTokens"]["tokenTypes"].Map(_.ToString())
            } catch {
                | _ => []
            };
            
            // available TokenTypes = client TokenTypes ∩ server TokenTypes
            tokenTypes = [
                "keyword",
                "string",
                "number",
                "variable"
            ].Intersect(supportedTokenTypes).ToArray();
            
            def capabilities = ServerCapabilities(
                documentHighlightProvider = true,
                textDocumentSync = TextDocumentSyncOptions(
                    openClose = true,
                    change = TextDocumentSyncKind.Full,
                ),
                semanticTokensProvider = SemanticTokensOptions(
                    legend = SemanticTokensLegend(tokenTypes.ToNList(), []), // TODO
                    range = false,
                    full = true,
                )
            );
            
            def assembly = Assembly.GetExecutingAssembly();
            def versionInfo = FileVersionInfo.GetVersionInfo(assembly.Location);
            def serverInfo = ServerInfo("atla-lsp", versionInfo.FileVersion);
            
            LSPResponseMessage.initializeResult(request.id(), capabilities, serverInfo)
        }
        
        public tokenize(uri: string): list[uint] {
            when (!buffers.ContainsKey(uri))
                return [];
            
            def text = buffers[uri];
            
            _tokenize(text)
        }
        
        public _tokenize(text: string): list[uint] {
            def lexer = Lexer();
            match (lexer.tokenize(text)) {
                | Result.Success(tokens, _) => {
                    mutable line = 0;
                    mutable col = 0;
                    def data = List();
                    foreach (token in tokens) {
                        def tline = token.span.lo.line;
                        def tcol = token.span.lo.col;
                        def tlen = token.span.hi.index - token.span.lo.index;
                        
                        def tokenType = match (token) {
                            | Token.Delim(s) when char.IsLetter(s.First()) => Some("keyword")
                            | Token.Int => Some("number")
                            | Token.String => Some("string")
                            | Token.Id => Some("variable")
                            | _ => None()
                        }
                        
                        def dline = tline - line;
                        def dcol = if (dline == 0) tcol - col else tcol;
                        
                        when (tokenType.IsSome && tokenTypes.Contains(tokenType.Value)) {
                            data.AddRange([dline, dcol, tlen, Array.IndexOf(tokenTypes, tokenType.Value), 0].Map(Convert.ToUInt32(_)));
                            line = token.span.lo.line;
                            col = token.span.lo.col;
                        }
                    }
                    data.ToNList()
                }
                | Result.Failure => []
            }
        }
        
        // TODO PublishDiagnosticsParamsを返す?
        public compile(uri: string, text: string): void {
            buffers[uri] = text;
            
            when (!isAvailablePublishDiagnostics)
                return;
            
            def lexer = Lexer();
            match (lexer.tokenize(text)) {
                | Result.Success(tokens, _) => {
                    def parser = Parser();
                    match (parser.mod.parse(TokenInput(tokens, 0))) {
                        | Result.Success(ast, _) => {
                            def moduleName = "main"; // TODO
                            def hir = Atla.Lang.Ast.Trans().trans(ast, moduleName);
                            def diagnostics = ast.scanErrors().Select((e, s) => {
                                Diagnostic(spanToRange(s), e)
                            }).Concat(hir.scanErrors().Select((e,s) => {
                                Diagnostic(spanToRange(s), e.ToString())
                            }));
                            
                            // 診断メッセージ置き換え(空配列ならクリアになる)
                            LSPNotificationMessage.publishDiagnostics(uri, diagnostics.ToList().ToNList()).sendMessage();
                            LSPNotificationMessage.windowLogMessage($"Parse>Success>CountDiagnostics> $(diagnostics.Count())", MessageType.Log).sendMessage();
                        }
                        | Result.Failure(reason, failAt) => {
                            def start = try {
                                def p = failAt.position() :> option[Atla.Lang.Parse.Span];
                                Atla.LanguageServer.Position(p.Value.lo.line, p.Value.lo.col)
                            } catch {
                                | _ => Atla.LanguageServer.Position(0, 0)
                            };
                            def end = try {
                                def p = failAt.position() :> option[Atla.Lang.Parse.Span];
                                Atla.LanguageServer.Position(p.Value.hi.line, p.Value.hi.col)
                            } catch {
                                | _ => Atla.LanguageServer.Position(text.Count(c => c == '\n'), text.Length - text.LastIndexOf('\n') + 1) // end of text
                            };
                    
                            LSPNotificationMessage.publishDiagnostics(uri, [
                                Diagnostic(Range(start, end), reason)
                            ]).sendMessage();
                            LSPNotificationMessage.windowLogMessage("Parse>Failure> ", MessageType.Log).sendMessage();
                        }
                    }
                }
                | Result.Failure(reason, failAt) => {
                    def start = try {
                        def p = failAt.position() :> Atla.Lang.Parse.Position;
                        Atla.LanguageServer.Position(p.line, p.col)
                    } catch {
                        | _ => Atla.LanguageServer.Position(0, 0)
                    };
                    def end = try {
                        def p = failAt.position() :> Atla.Lang.Parse.Position;
                        Atla.LanguageServer.Position(p.line, p.col + 1)
                    } catch {
                        | _ => Atla.LanguageServer.Position(text.Count(c => c == '\n'), text.Length - text.LastIndexOf('\n') + 1) // end of text
                    };
                    
                    LSPNotificationMessage.publishDiagnostics(uri, [
                        Diagnostic(Range(start, end), reason)
                    ]).sendMessage();
                    LSPNotificationMessage.windowLogMessage("Lexer>Failure> ", MessageType.Log).sendMessage();
                }
            }
        }
        
        spanToRange(span: Atla.Lang.Parse.Span): Range {
            def start = Atla.LanguageServer.Position(span.lo.line, span.lo.col);
            def end = Atla.LanguageServer.Position(span.hi.line, span.hi.col);
            Range(start, end)
        }
    }
}
